/* automatically generated by rust-bindgen 0.65.1 */

#[doc = " @brief Identifier for an object (cell, edge, etc) in the H3 system.\n\n The H3Index fits within a 64-bit unsigned integer."]
pub type H3Index = u64;
#[doc = " @brief Result code (success or specific error) from an H3 operation"]
pub type H3Error = u32;
#[doc = " @struct LatLng\n@brief latitude/longitude in radians"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LatLng {
    #[doc = "< latitude in radians"]
    pub lat: f64,
    #[doc = "< longitude in radians"]
    pub lng: f64,
}
#[doc = " @struct CellBoundary\n@brief cell boundary in latitude/longitude"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CellBoundary {
    #[doc = "< number of vertices"]
    pub numVerts: ::std::os::raw::c_int,
    #[doc = "< vertices in ccw order"]
    pub verts: [LatLng; 10usize],
}
#[doc = " @struct GeoLoop\n  @brief similar to CellBoundary, but requires more alloc work"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GeoLoop {
    pub numVerts: ::std::os::raw::c_int,
    pub verts: *mut LatLng,
}
#[doc = " @struct GeoPolygon\n  @brief Simplified core of GeoJSON Polygon coordinates definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GeoPolygon {
    #[doc = "< exterior boundary of the polygon"]
    pub geoloop: GeoLoop,
    #[doc = "< number of elements in the array pointed to by holes"]
    pub numHoles: ::std::os::raw::c_int,
    #[doc = "< interior boundaries (holes) in the polygon"]
    pub holes: *mut GeoLoop,
}
#[doc = " @struct GeoMultiPolygon\n  @brief Simplified core of GeoJSON MultiPolygon coordinates definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GeoMultiPolygon {
    pub numPolygons: ::std::os::raw::c_int,
    pub polygons: *mut GeoPolygon,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LinkedLatLng {
    pub vertex: LatLng,
    pub next: *mut LinkedLatLng,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LinkedGeoLoop {
    pub first: *mut LinkedLatLng,
    pub last: *mut LinkedLatLng,
    pub next: *mut LinkedGeoLoop,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LinkedGeoPolygon {
    pub first: *mut LinkedGeoLoop,
    pub last: *mut LinkedGeoLoop,
    pub next: *mut LinkedGeoPolygon,
}
#[doc = " @struct CoordIJ\n @brief IJ hexagon coordinates\n\n Each axis is spaced 120 degrees apart."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoordIJ {
    #[doc = "< i component"]
    pub i: ::std::os::raw::c_int,
    #[doc = "< j component"]
    pub j: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_LatLng() {
    const UNINIT: ::std::mem::MaybeUninit<LatLng> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LatLng>(),
        16usize,
        concat!("Size of: ", stringify!(LatLng))
    );
    assert_eq!(
        ::std::mem::align_of::<LatLng>(),
        8usize,
        concat!("Alignment of ", stringify!(LatLng))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LatLng),
            "::",
            stringify!(lat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lng) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LatLng),
            "::",
            stringify!(lng)
        )
    );
}
#[test]
fn bindgen_test_layout_CellBoundary() {
    const UNINIT: ::std::mem::MaybeUninit<CellBoundary> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CellBoundary>(),
        168usize,
        concat!("Size of: ", stringify!(CellBoundary))
    );
    assert_eq!(
        ::std::mem::align_of::<CellBoundary>(),
        8usize,
        concat!("Alignment of ", stringify!(CellBoundary))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numVerts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CellBoundary),
            "::",
            stringify!(numVerts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verts) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CellBoundary),
            "::",
            stringify!(verts)
        )
    );
}
#[test]
fn bindgen_test_layout_GeoLoop() {
    const UNINIT: ::std::mem::MaybeUninit<GeoLoop> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GeoLoop>(),
        16usize,
        concat!("Size of: ", stringify!(GeoLoop))
    );
    assert_eq!(
        ::std::mem::align_of::<GeoLoop>(),
        8usize,
        concat!("Alignment of ", stringify!(GeoLoop))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numVerts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GeoLoop),
            "::",
            stringify!(numVerts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verts) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GeoLoop),
            "::",
            stringify!(verts)
        )
    );
}
#[test]
fn bindgen_test_layout_GeoPolygon() {
    const UNINIT: ::std::mem::MaybeUninit<GeoPolygon> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GeoPolygon>(),
        32usize,
        concat!("Size of: ", stringify!(GeoPolygon))
    );
    assert_eq!(
        ::std::mem::align_of::<GeoPolygon>(),
        8usize,
        concat!("Alignment of ", stringify!(GeoPolygon))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoloop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GeoPolygon),
            "::",
            stringify!(geoloop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numHoles) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GeoPolygon),
            "::",
            stringify!(numHoles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).holes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GeoPolygon),
            "::",
            stringify!(holes)
        )
    );
}
#[test]
fn bindgen_test_layout_GeoMultiPolygon() {
    const UNINIT: ::std::mem::MaybeUninit<GeoMultiPolygon> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GeoMultiPolygon>(),
        16usize,
        concat!("Size of: ", stringify!(GeoMultiPolygon))
    );
    assert_eq!(
        ::std::mem::align_of::<GeoMultiPolygon>(),
        8usize,
        concat!("Alignment of ", stringify!(GeoMultiPolygon))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numPolygons) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GeoMultiPolygon),
            "::",
            stringify!(numPolygons)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).polygons) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GeoMultiPolygon),
            "::",
            stringify!(polygons)
        )
    );
}
#[test]
fn bindgen_test_layout_LinkedLatLng() {
    const UNINIT: ::std::mem::MaybeUninit<LinkedLatLng> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LinkedLatLng>(),
        24usize,
        concat!("Size of: ", stringify!(LinkedLatLng))
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedLatLng>(),
        8usize,
        concat!("Alignment of ", stringify!(LinkedLatLng))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedLatLng),
            "::",
            stringify!(vertex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedLatLng),
            "::",
            stringify!(next)
        )
    );
}
#[test]
fn bindgen_test_layout_LinkedGeoLoop() {
    const UNINIT: ::std::mem::MaybeUninit<LinkedGeoLoop> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LinkedGeoLoop>(),
        24usize,
        concat!("Size of: ", stringify!(LinkedGeoLoop))
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedGeoLoop>(),
        8usize,
        concat!("Alignment of ", stringify!(LinkedGeoLoop))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedGeoLoop),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedGeoLoop),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedGeoLoop),
            "::",
            stringify!(next)
        )
    );
}
#[test]
fn bindgen_test_layout_LinkedGeoPolygon() {
    const UNINIT: ::std::mem::MaybeUninit<LinkedGeoPolygon> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LinkedGeoPolygon>(),
        24usize,
        concat!("Size of: ", stringify!(LinkedGeoPolygon))
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedGeoPolygon>(),
        8usize,
        concat!("Alignment of ", stringify!(LinkedGeoPolygon))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedGeoPolygon),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedGeoPolygon),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedGeoPolygon),
            "::",
            stringify!(next)
        )
    );
}
#[test]
fn bindgen_test_layout_CoordIJ() {
    const UNINIT: ::std::mem::MaybeUninit<CoordIJ> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CoordIJ>(),
        8usize,
        concat!("Size of: ", stringify!(CoordIJ))
    );
    assert_eq!(
        ::std::mem::align_of::<CoordIJ>(),
        4usize,
        concat!("Alignment of ", stringify!(CoordIJ))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CoordIJ),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).j) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CoordIJ),
            "::",
            stringify!(j)
        )
    );
}
extern "C" {
    pub fn latLngToCell(g: *const LatLng, res: ::std::os::raw::c_int, out: *mut H3Index)
        -> H3Error;
}
extern "C" {
    pub fn cellToLatLng(h3: H3Index, g: *mut LatLng) -> H3Error;
}
extern "C" {
    pub fn cellToBoundary(h3: H3Index, gp: *mut CellBoundary) -> H3Error;
}
extern "C" {
    pub fn maxGridDiskSize(k: ::std::os::raw::c_int, out: *mut i64) -> H3Error;
}
extern "C" {
    pub fn gridDiskUnsafe(origin: H3Index, k: ::std::os::raw::c_int, out: *mut H3Index) -> H3Error;
}
extern "C" {
    pub fn gridDiskDistancesUnsafe(
        origin: H3Index,
        k: ::std::os::raw::c_int,
        out: *mut H3Index,
        distances: *mut ::std::os::raw::c_int,
    ) -> H3Error;
}
extern "C" {
    pub fn gridDiskDistancesSafe(
        origin: H3Index,
        k: ::std::os::raw::c_int,
        out: *mut H3Index,
        distances: *mut ::std::os::raw::c_int,
    ) -> H3Error;
}
extern "C" {
    pub fn gridDisksUnsafe(
        h3Set: *mut H3Index,
        length: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        out: *mut H3Index,
    ) -> H3Error;
}
extern "C" {
    pub fn gridDisk(origin: H3Index, k: ::std::os::raw::c_int, out: *mut H3Index) -> H3Error;
}
extern "C" {
    pub fn gridDiskDistances(
        origin: H3Index,
        k: ::std::os::raw::c_int,
        out: *mut H3Index,
        distances: *mut ::std::os::raw::c_int,
    ) -> H3Error;
}
extern "C" {
    pub fn gridRingUnsafe(origin: H3Index, k: ::std::os::raw::c_int, out: *mut H3Index) -> H3Error;
}
extern "C" {
    pub fn maxPolygonToCellsSize(
        geoPolygon: *const GeoPolygon,
        res: ::std::os::raw::c_int,
        flags: u32,
        out: *mut i64,
    ) -> H3Error;
}
extern "C" {
    pub fn polygonToCells(
        geoPolygon: *const GeoPolygon,
        res: ::std::os::raw::c_int,
        flags: u32,
        out: *mut H3Index,
    ) -> H3Error;
}
extern "C" {
    pub fn cellsToLinkedMultiPolygon(
        h3Set: *const H3Index,
        numHexes: ::std::os::raw::c_int,
        out: *mut LinkedGeoPolygon,
    ) -> H3Error;
}
extern "C" {
    pub fn destroyLinkedMultiPolygon(polygon: *mut LinkedGeoPolygon);
}
extern "C" {
    pub fn degsToRads(degrees: f64) -> f64;
}
extern "C" {
    pub fn radsToDegs(radians: f64) -> f64;
}
extern "C" {
    pub fn greatCircleDistanceRads(a: *const LatLng, b: *const LatLng) -> f64;
}
extern "C" {
    pub fn greatCircleDistanceKm(a: *const LatLng, b: *const LatLng) -> f64;
}
extern "C" {
    pub fn greatCircleDistanceM(a: *const LatLng, b: *const LatLng) -> f64;
}
extern "C" {
    pub fn getHexagonAreaAvgKm2(res: ::std::os::raw::c_int, out: *mut f64) -> H3Error;
}
extern "C" {
    pub fn getHexagonAreaAvgM2(res: ::std::os::raw::c_int, out: *mut f64) -> H3Error;
}
extern "C" {
    pub fn cellAreaRads2(h: H3Index, out: *mut f64) -> H3Error;
}
extern "C" {
    pub fn cellAreaKm2(h: H3Index, out: *mut f64) -> H3Error;
}
extern "C" {
    pub fn cellAreaM2(h: H3Index, out: *mut f64) -> H3Error;
}
extern "C" {
    pub fn getHexagonEdgeLengthAvgKm(res: ::std::os::raw::c_int, out: *mut f64) -> H3Error;
}
extern "C" {
    pub fn getHexagonEdgeLengthAvgM(res: ::std::os::raw::c_int, out: *mut f64) -> H3Error;
}
extern "C" {
    pub fn edgeLengthRads(edge: H3Index, length: *mut f64) -> H3Error;
}
extern "C" {
    pub fn edgeLengthKm(edge: H3Index, length: *mut f64) -> H3Error;
}
extern "C" {
    pub fn edgeLengthM(edge: H3Index, length: *mut f64) -> H3Error;
}
extern "C" {
    pub fn getNumCells(res: ::std::os::raw::c_int, out: *mut i64) -> H3Error;
}
extern "C" {
    pub fn res0CellCount() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getRes0Cells(out: *mut H3Index) -> H3Error;
}
extern "C" {
    pub fn pentagonCount() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getPentagons(res: ::std::os::raw::c_int, out: *mut H3Index) -> H3Error;
}
extern "C" {
    pub fn getResolution(h: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getBaseCellNumber(h: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stringToH3(str_: *const ::std::os::raw::c_char, out: *mut H3Index) -> H3Error;
}
extern "C" {
    pub fn h3ToString(h: H3Index, str_: *mut ::std::os::raw::c_char, sz: usize) -> H3Error;
}
extern "C" {
    pub fn isValidCell(h: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cellToParent(
        h: H3Index,
        parentRes: ::std::os::raw::c_int,
        parent: *mut H3Index,
    ) -> H3Error;
}
extern "C" {
    pub fn cellToChildrenSize(
        h: H3Index,
        childRes: ::std::os::raw::c_int,
        out: *mut i64,
    ) -> H3Error;
}
extern "C" {
    pub fn cellToChildren(
        h: H3Index,
        childRes: ::std::os::raw::c_int,
        children: *mut H3Index,
    ) -> H3Error;
}
extern "C" {
    pub fn cellToCenterChild(
        h: H3Index,
        childRes: ::std::os::raw::c_int,
        child: *mut H3Index,
    ) -> H3Error;
}
extern "C" {
    pub fn cellToChildPos(
        child: H3Index,
        parentRes: ::std::os::raw::c_int,
        out: *mut i64,
    ) -> H3Error;
}
extern "C" {
    pub fn childPosToCell(
        childPos: i64,
        parent: H3Index,
        childRes: ::std::os::raw::c_int,
        child: *mut H3Index,
    ) -> H3Error;
}
extern "C" {
    pub fn compactCells(
        h3Set: *const H3Index,
        compactedSet: *mut H3Index,
        numHexes: i64,
    ) -> H3Error;
}
extern "C" {
    pub fn uncompactCellsSize(
        compactedSet: *const H3Index,
        numCompacted: i64,
        res: ::std::os::raw::c_int,
        out: *mut i64,
    ) -> H3Error;
}
extern "C" {
    pub fn uncompactCells(
        compactedSet: *const H3Index,
        numCompacted: i64,
        outSet: *mut H3Index,
        numOut: i64,
        res: ::std::os::raw::c_int,
    ) -> H3Error;
}
extern "C" {
    pub fn isResClassIII(h: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isPentagon(h: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn maxFaceCount(h3: H3Index, out: *mut ::std::os::raw::c_int) -> H3Error;
}
extern "C" {
    pub fn getIcosahedronFaces(h3: H3Index, out: *mut ::std::os::raw::c_int) -> H3Error;
}
extern "C" {
    pub fn areNeighborCells(
        origin: H3Index,
        destination: H3Index,
        out: *mut ::std::os::raw::c_int,
    ) -> H3Error;
}
extern "C" {
    pub fn cellsToDirectedEdge(origin: H3Index, destination: H3Index, out: *mut H3Index)
        -> H3Error;
}
extern "C" {
    pub fn isValidDirectedEdge(edge: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getDirectedEdgeOrigin(edge: H3Index, out: *mut H3Index) -> H3Error;
}
extern "C" {
    pub fn getDirectedEdgeDestination(edge: H3Index, out: *mut H3Index) -> H3Error;
}
extern "C" {
    pub fn directedEdgeToCells(edge: H3Index, originDestination: *mut H3Index) -> H3Error;
}
extern "C" {
    pub fn originToDirectedEdges(origin: H3Index, edges: *mut H3Index) -> H3Error;
}
extern "C" {
    pub fn directedEdgeToBoundary(edge: H3Index, gb: *mut CellBoundary) -> H3Error;
}
extern "C" {
    pub fn cellToVertex(
        origin: H3Index,
        vertexNum: ::std::os::raw::c_int,
        out: *mut H3Index,
    ) -> H3Error;
}
extern "C" {
    pub fn cellToVertexes(origin: H3Index, vertexes: *mut H3Index) -> H3Error;
}
extern "C" {
    pub fn vertexToLatLng(vertex: H3Index, point: *mut LatLng) -> H3Error;
}
extern "C" {
    pub fn isValidVertex(vertex: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gridDistance(origin: H3Index, h3: H3Index, distance: *mut i64) -> H3Error;
}
extern "C" {
    pub fn gridPathCellsSize(start: H3Index, end: H3Index, size: *mut i64) -> H3Error;
}
extern "C" {
    pub fn gridPathCells(start: H3Index, end: H3Index, out: *mut H3Index) -> H3Error;
}
extern "C" {
    pub fn cellToLocalIj(origin: H3Index, h3: H3Index, mode: u32, out: *mut CoordIJ) -> H3Error;
}
extern "C" {
    pub fn localIjToCell(
        origin: H3Index,
        ij: *const CoordIJ,
        mode: u32,
        out: *mut H3Index,
    ) -> H3Error;
}
